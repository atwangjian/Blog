{"meta":{"title":"wangjian - 爱编程，爱折腾","subtitle":"个人博客小站","description":"wangjian博客","author":"wangjian","url":"http://atwangjian.cn"},"pages":[{"title":"关于","date":"2017-06-14T09:16:21.000Z","updated":"2020-04-05T13:23:03.738Z","comments":true,"path":"about/index.html","permalink":"http://atwangjian.cn/about/index.html","excerpt":"","text":"我 2019年7月毕业，软件工程专业 现工作于南京，任职软件开发工程师 联系邮箱876027276@qq.com 友链 名称 + 链接Send My Email 欢迎技术交流~"},{"title":"折腾记录","date":"2017-06-14T09:16:21.000Z","updated":"2020-04-12T06:17:56.518Z","comments":true,"path":"build/index.html","permalink":"http://atwangjian.cn/build/index.html","excerpt":"","text":"诞生2018年某月某天：博客搭建，域名：javacat.cn（未续费，被注了…）一万字…… 历程2020年4月1日：注册域名atwangjian.cn，博客重造2020年4月3日：完成基本功能2020年4月5日：解决搜索功能bug；接入valine评论；增加代码块复制功能；代码块美化；接入Aplayer音乐播放器。搞完23:56 休息~ .2020年4月10日:评论发邮件功能 存在bug:音乐播放异常"},{"title":"","date":"2017-06-14T09:16:21.000Z","updated":"2020-04-19T14:13:35.766Z","comments":false,"path":"others/index.html","permalink":"http://atwangjian.cn/others/index.html","excerpt":"","text":"愿你在我看不到的地方安然无恙，愿你的冬天永远不缺暖阳。愿你的明天不再经历雨打风霜，愿你的未来永远热泪盈眶。"},{"title":"记性不好","date":"2017-06-14T09:16:21.000Z","updated":"2020-04-05T14:55:15.404Z","comments":true,"path":"bookmark/index.html","permalink":"http://atwangjian.cn/bookmark/index.html","excerpt":"","text":"开发java知识分享网：http://www.java1234.comhow2j：https://how2j.cnleancloud：https://www.leancloud.cn黑马：http://yun.itheima.com/course?jingjiahmpz-pz-pc-biaoti 娱乐vip视频破解：http://www.66re.cn/vip音乐直链搜索：https://music.liuzhijin.cn"}],"posts":[{"title":"Java系统定制","slug":"fuye","date":"2020-04-19T13:50:05.795Z","updated":"2020-04-19T14:42:12.549Z","comments":true,"path":"fuye.html","link":"","permalink":"http://atwangjian.cn/fuye.html","excerpt":"","text":"服务范围我们团队（我一个人）可以根据用户的功能要求，量身定制Java系统设计程序。需要用户提供详细的功能要求。联系本站客服QQ：876027276给我发消息告知。我们会根据用户系统的难易程度，工作量大小等，具体的给出一个报价。价格协商一致过后，付下40%定金。我们开始开发（中途可以联系我们查看进度）。做好过后先发送设计桌面演示录像，用户看后满意付尾款，我们再发程序源码压缩包。 售后服务包指导配置环境，远程调试运行一次，在用户自己电脑上面运行起来。 示例商城系统","categories":[],"tags":[],"keywords":[]},{"title":"一头扎进强大的Stream Api","slug":"java/1","date":"2020-04-18T13:02:27.038Z","updated":"2020-04-19T13:48:09.044Z","comments":true,"path":"java/1.html","link":"","permalink":"http://atwangjian.cn/java/1.html","excerpt":"","text":"写在前面：为啥要学Java8？我不管java8有多牛逼，只要是项目用了jdk1.8，就会有程序员用java8的语法写代码，所有我的理由很简单：为了看懂别人写的代码。 一.一头扎进Stream1.1 啥是Stream1.Stream API ( java.util.stream) 把真正的函数式编程风格引入到是目前为止对Java类库最好的补充，因为Stream API可以极大序员的生产力，让程序员写出高效率、干净、简洁的代码。2.Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 1.2 特点1.Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算2.Stream关注的是对数据的运算，与CPU打交道,集合关注的是对数据的存储，与内存打交道3.（1）Stream 自己不会存储元素 （2）Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream （3）Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行4.Stream执行流程:(1)Stream的实例化(2)一系列的中间操作（过滤，映射……）(3)终止操作 二.Stream操作三步骤2.1 创建 Stream的方式（1）通过集合Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：●default Stream stream() : 返回一个顺序流●default Stream parallelStream() : 返回一个并行流 （2）通过数组Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：●static Stream stream(T[] array): 返回一个流重载形式，能够处理对应基本类型的数组：●public static IntStream stream(int[] array)●public static LongStream stream(long[] array)●public static DoubleStream stream(double[] array) （3）通过Stream的of() 可以调用Stream类静态方法 of(), 通过显示值创建一流。它可以接收任意数量的参数。●public static Stream of(T… values) : 返回一个流 （4）创建无限流可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。●迭代public static Stream iterate(final T seed, final UnaryOperator f)●生成public static Stream generate(Supplier s) 2.2 中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。(1)筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda ， 从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 （2）映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 （3）排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序 2.3 终止操作●终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。●流进行了终止操作后，不能再次使用。（1）匹配与查找 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c)/td> 内部迭代 （2）归约 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google用它来进行网络搜索而出名。 （3）收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。 另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例。 三.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package main.java8;import main.entity.User;import org.junit.Test;import javax.sound.midi.Soundbank;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;import java.util.List;import java.util.Optional;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.IntStream;import java.util.stream.Stream;/*** @author wangjian* @date 2020/4/15 21:40*/public class StreamTest &#123; @Test public void test1() &#123; // 1.通过集合 List&lt;User&gt; list = User.getUserList(); // 1.1 顺序流 Stream&lt;User&gt; stream = list.stream(); // 1.2 并行流 Stream&lt;User&gt; userStream = list.parallelStream(); // 2. 通过数组 int[] ints = new int[]&#123;1, 2, 3, 4, 5&#125;; IntStream intStream = Arrays.stream(ints); User u1 = new User(11, \"firse\", \"123465\"); User u2 = new User(12, \"secong\", \"sdfasdf\"); User[] users = new User[]&#123;u1, u2&#125;; Stream&lt;User&gt; userStream1 = Arrays.stream(users); // 3. 通过Stream的of() Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6); // 4. 创建无限流 // 4.1 迭代 Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out::println); // 4.2 生成 Stream.generate(Math::random).limit(10).forEach(System.out::println); &#125; /** * 中间操作 */ @Test public void test2() &#123; System.out.println(\"========1.筛选与切片============\"); // 1.筛选与切片 List&lt;User&gt; list = User.getUserList(); // 1.1 filter(Predicate p)，接收Lambda，从流中排除某些元素。查询id大于5的数据 list.stream().filter(e -&gt; e.getId() &gt; 5).forEach(System.out::println); System.out.println(); // 1.2 limit(n)，截断流，使其元素不超过给定数量 list.stream().limit(5).forEach(System.out::println); System.out.println(); // 1.3 skip(n)，跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。 list.stream().skip(5).forEach(System.out::println); System.out.println(); // 1.4 distinct()，去重（通过流所生成元素的hashCode()和equals()去除重复元素） List list1 = new ArrayList(); list1.add(\"1\"); list1.add(\"2\"); list1.add(\"3\"); list1.add(\"1\"); System.out.println(\"当前list1:\" + list1); System.out.println(); list1.stream().distinct().forEach(System.out::println); // 2.映射 System.out.println(\"===========2.map映射============\"); list.add(new User(15, \"张三丰\", \"123456789\")); // 获取用户名长度大于3的用户名的姓名 list.stream().map(e -&gt; e.getUserName()).filter(userName -&gt; userName.length() &gt; 2).forEach(System.out::println); List&lt;String&gt; list2 = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\"); list2.stream().map(e -&gt; e.toUpperCase()).forEach(System.out::println); // 3.排序 System.out.println(\"===========3.排序============\"); List&lt;Integer&gt; list3 = Arrays.asList(1, 2, 4, 63, 0, -5, 23, 1231); list3.stream().sorted().forEach(System.out::println); list.stream().sorted((e1, e2) -&gt; Integer.compare(e1.getId(), e2.getId())).forEach(System.out::println); System.out.println(\"排序多判断条件：\"); list.add(new User(15, \"李四\", \"123123\")); list.stream().sorted((e1, e2) -&gt; &#123; int idValue = Integer.compare(e1.getId(), e2.getId()); if (idValue != 0) &#123; return idValue; &#125; else &#123; return -Integer.compare(e1.getId(), e2.getId()); &#125; &#125;).forEach(System.out::println); &#125; @Test public void test3() &#123; // 1.匹配与查找 System.out.println(\"==============匹配与查找=============\"); // 1.1 allMatch(Predicate p) 检查是否匹配所有元素：是否所有的id都大于15 List&lt;User&gt; list = User.getUserList(); boolean allMatch = list.stream().allMatch(e -&gt; e.getId() &gt; 10); System.out.println(allMatch); // 1.2 anyMatch(Predicate p) 检查是否至少匹配一个元素 boolean anyMatch = list.stream().anyMatch(e -&gt; e.getId() == 11); System.out.println(anyMatch); // 1.3 noneMatch(Predicate p) 检查是否没有匹配所有元素 boolean noneMatch = list.stream().noneMatch(e -&gt; e.getId() &gt; 12); System.out.println(noneMatch); // 1.4 findFirst() 返回第一个元素 Optional&lt;String&gt; first = list.stream().map(e -&gt; e.getUserName()).findFirst(); System.out.println(first); // 1.5 findAny() 返回当前流中的任意元素 Optional&lt;String&gt; any = list.parallelStream().map(e -&gt; e.getUserName()).findAny(); System.out.println(any); // 1.6 count() 返回流中元素总数 long count = list.stream().count(); System.out.println(count); // 1.7 max(Comparator c) 返回流中最大值 Optional&lt;Integer&gt; max = list.stream().map(e -&gt; e.getId()).max(Integer::compare); System.out.println(max); // 1.8 min(Comparator c) 返回流中最小值 Optional&lt;Integer&gt; min = list.stream().map(e -&gt; e.getId()).min(Integer::compare); System.out.println(min); // 1.9 forEach(Consumer c),内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代) list.stream().forEach(System.out::println); // 2. 归约 // 2.1 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T System.out.println(\"==============归约=============\"); // 计算1-10的自然数的和 List&lt;Integer&gt; list1 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer sum = list1.stream().reduce(0, Integer::sum); System.out.println(sum); // reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt; // 计算所有id的和 Optional&lt;Integer&gt; idSum = list.stream().map(e -&gt; e.getId()).reduce(Integer::sum); System.out.println(idSum); Optional&lt;Integer&gt; idSum2 = list.stream().map(e -&gt; e.getId()).reduce((d1, d2) -&gt; d1 + d2); System.out.println(idSum2); // 3.收集 // collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 System.out.println(\"============收集===========\"); List&lt;User&gt; idList = list.stream().filter(e -&gt; e.getId() &gt; 5).collect(Collectors.toList()); System.out.println(idList); Set&lt;User&gt; idSet = list.stream().filter(e -&gt; e.getId() &gt; 5).collect(Collectors.toSet()); System.out.println(idSet); &#125;&#125;","categories":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/categories/java8/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/tags/java8/"}],"keywords":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/categories/java8/"}]},{"title":"Spring事务","slug":"spring/1","date":"2020-04-08T14:36:07.841Z","updated":"2020-04-14T14:00:13.173Z","comments":true,"path":"spring/1.html","link":"","permalink":"http://atwangjian.cn/spring/1.html","excerpt":"","text":"一.事务的概念和特性概念：事务指的是逻辑上的一组操作，这个操作要么全部成功，要么全部失败。特性： 特性 描述 原子性 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生 一致性 事务前后数据的完整性必须保持一致 隔离性 多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离 持久性 一个事务一旦被提交，它对数据库中数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响 二.事务的APISpring事务管理高层抽象主要包括3个接口PlatformTransactionManager:事务管理器TransactionDefinition:事务定义信息（隔离，传播，超时，只读）TransactionStatus:事务具体运行状态 2.1 PlatformTransactionManagerSpring为不同的持久化框架提供了不同PlatformTransactionManager接口实现,该接口中提供了三个事务操作方法，具体如下。TransactionStatus getTransaction（TransactionDefinition definition）：用于获取事务状态信息。void commit（TransactionStatus status）：用于提交事务。void rollback（TransactionStatus status）：用于回滚事务。 事务 说明 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用Spring JDBC或ibatis进行持久化数据时使用 org.springframework.orm.hibernate3.HibernateTransactionManager 使用Hibernate3.0版本进行持久化数据时使用 org.springframework.orm.jpa.JpaTransactionManager 使用JPA进行持久时使用 org.springframework.orm.jdo.JdoTransactionManager 当持久化机制是Jdo时使用 org.springframework.transaction.jta.JtaTransactionManager 使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用 2.2 TransactionDefinitionTransactionDefinition 接口是事务定义（描述）的对象，它提供了事务相关信息获取的方法，其中包括五个操作，具体如下。String getName()：获取事务对象名称。int getIsolationLevel()：获取事务的隔离级别。int getPropagationBehavior()：获取事务的传播行为。int getTimeout()：获取事务的超时时间。boolean isReadOnly()：获取事务是否只读。 2.2.1 隔离级别 隔离级别 含义 DEFAULT 使用后端数据库默认的隔离级别（srping中的选择项） READ_UNCOMMITED 允许你读取还未提交的改变了的数据，可能导致脏，幻，不可重复读 READ_UNCOMMITTED 允许在并发事务已经提交后读取，可防止脏读，但幻读和不可重复读仍可发生 REPEATABLE_READ 对相同字段的多次读取时一致的，除非数据被事务本身改变，可防止脏，不可重复读，但幻读仍可能发生 SERIALIZABLE 完全服从ACID的隔离级别，确保不发生脏，幻，不可重复读。这在所有的隔离级别中是最低的，它是典型的通过完全锁定在事务中涉及的数据表来完成的 Mysql默认采用REPEATABLE_READ隔离级别，Oracle默认采用READ_COMMITTED隔离级别。 脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。不可重复读：在同一个事务中，多次读取同一数据返回的结果有所不同。幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。 2.2.1 传播行为 事务传播行为类型 说明 PROPAGATION_REQUIRED 支持当前事务，假设当前没有事务。就新建一个事务） PROPAGATION_SUPPORTS 支持当前事务，假设当前没有事务，就以非事务方式运行 PROPAGATION_MANDATORY 支持当前事务，假设当前没有事务，就抛出异常 PROPAGATION_REQUIRES_NEW 新建事务，假设当前存在事务。把当前事务挂起 PROPAGATION_NOT_SUPPORTED 以非事务方式运行操作。假设当前存在事务，就把当前事务挂起 PROPAGATION_NEVER 以非事务方式运行，假设当前存在事务，则抛出异常 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 aaa,bbb的这2个操作是在一个事务里面的aaa,bbb的这2个操作不在一个事务里面的aaa执行完以后，设置一个保存点，当bbb发生异常以后，回滚到保存点或最初始状态 3.1 TransactionStatusTransactionStatus 接口是事务的状态，它描述了某一时间点上事务的状态信息。其中包含六个操作void flush() 刷新事务boolean hasSavepoint() 获取是否存在保存点boolean isCompleted() 获取事务是否完成boolean isNewTransaction() 获取是否是新事务boolean isRollbackOnly() 获取是否回滚void setRollbackOnly() 设置事务回滚 其他博客：https://blog.csdn.net/qq_38526573/article/details/87898161","categories":[{"name":"Spring","slug":"Spring","permalink":"http://atwangjian.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://atwangjian.cn/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://atwangjian.cn/categories/Spring/"}]},{"title":"测试专用","slug":"test","date":"2020-04-05T12:25:25.429Z","updated":"2020-04-05T13:38:50.509Z","comments":true,"path":"test.html","link":"","permalink":"http://atwangjian.cn/test.html","excerpt":"","text":"一级目录testasdfasdfasddddddddddddddsdafdasfsdafasdfsdfsdafsdafdsf sdfsdf dsfsdafasdfasdf asdfasdfasddddddddddddddsdafdasfsdafasdfsdfsdafsdafdsf sdfsdf dsfasdfasdfasdf asdfasdfasddddddddddddddsdafdasfsdafasdfsdfsdafsdafdsf sdfsdf sdafasdfsasdfasdfasddddddddddddddsdafdasfsdafasdfsdfsdafsdafdsf sdfsdf 测试测试测试 位运算 符号 计算 按位与 &amp; 相同为1，不同为0 按位或 &#124; 有1则1 按位异或 ^ 相同为0，不同位1 按位取反 ~ 左移 &lt;&lt; 相当于乘以2^n^ 右移 &gt;&gt; 相当于除以2^n^ 无符号右移 &gt;&gt;&gt;","categories":[{"name":"测试","slug":"测试","permalink":"http://atwangjian.cn/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://atwangjian.cn/tags/%E6%B5%8B%E8%AF%95/"}],"keywords":[{"name":"测试","slug":"测试","permalink":"http://atwangjian.cn/categories/%E6%B5%8B%E8%AF%95/"}]},{"title":"Java工具类","slug":"tools","date":"2020-04-03T09:16:21.000Z","updated":"2020-04-05T14:52:49.313Z","comments":false,"path":"tools.html","link":"","permalink":"http://atwangjian.cn/tools.html","excerpt":"","text":"一.String字符串1.对字符串去除符号并转为json123456789101112131415public static void removeSymbol() &#123; String msg = \"\\\"&#123;\\\"name\\\": \\\"张三\\\",\\\"password\\\": \\\"@123456\\\",\\\"age\\\": \\\"15\\\"&#125;\\\"\"; // 去除转义 String msg1 = msg.replaceAll(\"\\\\\\\\\", \"\"); System.out.println(\"原来字符串:\"+msg); System.out.println(\"去除转义:\"+msg1); // 去除首尾\"\" String msg2 = msg1.substring(1, msg1.length() - 1); System.out.println(\"去除首尾双引号:\"+msg2); // 转为json JSONObject json = JSONObject.parseObject(msg2); System.out.println(\"转为json\"+json); String name = json.getString(\"name\"); System.out.println(\"json中name的值:\" + name);&#125; 运行结果： 12345原来字符串:\"&#123;\"name\": \"张三\",\"password\": \"@123456\",\"age\": \"15\"&#125;\"去除转义:\"&#123;\"name\": \"张三\",\"password\": \"@123456\",\"age\": \"15\"&#125;\"去除首尾双引号:&#123;\"name\": \"张三\",\"password\": \"@123456\",\"age\": \"15\"&#125;转为json&#123;\"password\":\"@123456\",\"name\":\"张三\",\"age\":\"15\"&#125;json中name的值:张三","categories":[{"name":"Java","slug":"Java","permalink":"http://atwangjian.cn/categories/Java/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"http://atwangjian.cn/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://atwangjian.cn/categories/Java/"}]},{"title":"留言板","slug":"liuyanban","date":"2020-02-02T14:22:22.000Z","updated":"2020-04-05T13:17:20.099Z","comments":true,"path":"liuyanban.html","link":"","permalink":"http://atwangjian.cn/liuyanban.html","excerpt":"","text":"欢迎留下你的足迹！点开留言板在评论区随便说点什么吧~","categories":[],"tags":[],"keywords":[]}]}