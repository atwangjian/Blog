{"meta":{"title":"wangjian - 爱编程，爱折腾","subtitle":"个人博客小站","description":"wangjian博客","author":"wangjian","url":"http://atwangjian.cn"},"pages":[{"title":"关于","date":"2017-06-14T09:16:21.000Z","updated":"2020-04-05T13:23:03.738Z","comments":true,"path":"about/index.html","permalink":"http://atwangjian.cn/about/index.html","excerpt":"","text":"我 2019年7月毕业，软件工程专业 现工作于南京，任职软件开发工程师 联系邮箱876027276@qq.com 友链 名称 + 链接Send My Email 欢迎技术交流~"},{"title":"记性不好","date":"2017-06-14T09:16:21.000Z","updated":"2020-04-19T14:59:15.312Z","comments":true,"path":"bookmark/index.html","permalink":"http://atwangjian.cn/bookmark/index.html","excerpt":"","text":"开发java知识分享网：http://www.java1234.comhow2j：https://how2j.cnleancloud：https://www.leancloud.cn黑马：http://yun.itheima.com/course?jingjiahmpz-pz-pc-biaoti 娱乐vip视频破解：http://www.66re.cn/vip音乐直链搜索：http://music.xf1433.com"},{"title":"折腾记录","date":"2017-06-14T09:16:21.000Z","updated":"2020-04-19T15:01:14.238Z","comments":true,"path":"build/index.html","permalink":"http://atwangjian.cn/build/index.html","excerpt":"","text":"初生2018年某月某天：博客搭建，域名：javacat.cn省略一万字…… 历程2020年4月1日：注册域名atwangjian.cn，博客重造2020年4月3日：完成基本功能2020年4月5日：解决搜索功能bug；接入valine评论；增加代码块复制功能；代码块美化；接入Aplayer音乐播放器2020年4月10日:评论发邮件功能"},{"title":"","date":"2017-06-14T09:16:21.000Z","updated":"2020-04-19T14:13:35.766Z","comments":false,"path":"others/index.html","permalink":"http://atwangjian.cn/others/index.html","excerpt":"","text":"愿你在我看不到的地方安然无恙，愿你的冬天永远不缺暖阳。愿你的明天不再经历雨打风霜，愿你的未来永远热泪盈眶。"}],"posts":[{"title":"Swagger和knife4j","slug":"middleware/3","date":"2020-05-27T12:30:09.859Z","updated":"2020-05-27T12:40:46.585Z","comments":true,"path":"middleware/3.html","link":"","permalink":"http://atwangjian.cn/middleware/3.html","excerpt":"","text":"Swagger篇一．简介1.什么是SwaggerSwagger是一组围绕OpenAPI规范构建的开源工具，可以帮助你设计、构建、记录和使用REST API。主要的Swagger工具包括：Swagger Editor：基于浏览器的编辑器，你可以在这里编写OpenAPI规范。Swagger UI：将OpenAPI规范渲染成交互式的API文档。Swagger Codegen：从OpenAPI规范中生成服务器存根和客户端库。 二．SSM整合Swagger1.引入Maven 1234567891011&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt; 2.添加SwaggerConfig 12345678910111213141516171819202122232425262728293031323334package cn.atwangjian.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.mvc.method.RequestMappingInfoHandlerMapping;import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;/** * @author wangjian * @date 2020/5/25 20:01 */@Configuration@EnableSwagger2public class SwaggerConfig &#123; @Bean public Docket userApi() &#123; return new Docket(DocumentationType.SWAGGER_2).select().apis(RequestHandlerSelectors.any()) .paths(PathSelectors.any()) .build(); &#125; @Bean public RequestMappingInfoHandlerMapping requestMapping() &#123; return new RequestMappingHandlerMapping(); &#125;&#125; 3.springMvc.xml添加Swagger配置 12345678910 &lt;!--添加swagger配置--&gt; &lt;!-- 引入swagger相关 --&gt; &lt;bean class=\"cn.atwangjian.config.SwaggerConfig\"/&gt; &lt;!--使用swagger --&gt; &lt;!--&lt;mvc:resources mapping=\"swagger-ui.html\" location=\"classpath:/META-INF/resources/\" /&gt;--&gt; &lt;!--使用knife4j --&gt; &lt;mvc:resources mapping=\"doc.html\" location=\"classpath:/META-INF/resources/\" /&gt; &lt;mvc:resources mapping=\"/webjars/**\" location=\"classpath:/META-INF/resources/webjars/\" /&gt; &lt;bean class=\"springfox.documentation.swagger2.configuration.Swagger2DocumentationConfiguration\" id=\"swagger2Config\"/&gt; 三．效果访问：http://IP:port/web-obj-name/swagger-ui.html 四．常用属性介绍12345678910111213141516171819202122232425262728293031@Api() 用于类；表示标识这个类是swagger的资源 tags–表示说明 value–也是说明，可以使用tags替代 @ApiOperation() 用于方法；表示一个http请求的操作 value用于方法描述 notes用于提示内容 tags可以重新分组@ApiParam() 用于方法，参数，字段说明；表示对参数的添加元数据（说明或是否必填等） name–参数名 value–参数说明 required–是否必填@ApiModel()用于类 ；表示对类进行说明，用于参数用实体类接收 value–表示对象名 description–描述 都可省略 @ApiModelProperty()用于方法，字段； 表示对model属性的说明或者数据操作更改 value–字段说明 name–重写属性名字 dataType–重写属性类型 required–是否必填 example–举例说明 hidden–隐藏 knife4j篇一．简介knife4j是为集成Swagger生成Api文档的增强解决方案 二．核心功能1.文档说明 knife4j的列出接口文档的说明，包括接口地址、请求方式、接口描述、请求类型、请求示例、请求参数、响应状态、响应示例等。2.在线调试 knife4j提供了强大的在线接口调试功能，自动解析当前接口参数，同时包含表单验证，调用参数可返回接口响应内容、Raw、Headers、Curl以及响应耗时等信息。帮助开发者在线调试，而不用通过其他三方工具测试接口是否正确。 三．SSM整合knife4j1.maven中引入jar包正如knife4j官网介绍所说，如果你是一名Java开发工程师,那么使用swagger-bootstrap-ui将会非常简单,只需要在原使用的基础上,添加swagger-bootstrap-ui的maven引用jar包即可。 123456789101112 &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.6.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt; &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt; &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt; 2.添加SwaggerConfig配置和springMvc配置 同swagger篇 四．效果访问地址：http://IP:port/web-obj-name/doc.html1.文档knife4j为我们写好了接口文档，可以直接复制导出，非常的方便。2.调试调试成功：调试报错都会显示：","categories":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"keywords":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"redis","slug":"middleware/2","date":"2020-05-23T09:03:40.363Z","updated":"2020-05-24T15:09:50.891Z","comments":true,"path":"middleware/2.html","link":"","permalink":"http://atwangjian.cn/middleware/2.html","excerpt":"","text":"一.简介1.1 redis简介redis是开源免费的高性能key-value数据库，属于NoSQL数据库。redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。redis支持数据的备份，即master-slave模式的数据备份。 redis与其他key-value缓存产品有如下三个特点：（1）性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。（2）丰富的数据类型 – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。（3）原子 – Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。（4）丰富的特性 – Redis还支持 发布订阅消息, 通知, key 过期等等特性。 1.2 redis安装下载地址（windows版本)https://github.com/MicrosoftArchive/redis/releases 完整版本下载地址（Linux）：http://download.redis.io/releases/ Redis Desktop Manager（可视化连接工具）下载地址：https://www.cr173.com/soft/73300.html 1.3 启动1.先启动服务端命令：redis-server.exe redis.windows.conf2.启动客户端命令：redis-cli.exe 二.redis数据结构，命令keys * : 查询所有的键type key ： 获取键对应的value的类型del key：删除指定的key value 2.1 Stringstring：字符串类型是非常常见的一种类型，Redis中的字符串类型和很多编程语言里的字符串类型差不多，但相对要灵活些。 12345678910set key value 设置key对应的值为string类型的value mset key1 value1 [key2 value2...] 一次设置多个key get key 获取指定key的value值 mget key1 [key2 ...] 一次获取多个key的value值 incr key 对key的值做自增操作，返回新的值 decr key 对key的值做自减操作，返回新的值 incrby key integer 对key的value加指定integer decrby key integer 对key的value减指定integer append key value 给指定key的字符串追加value substr key start end 截取key，从start（包含）到end（包含）。注意只是返回截取的value，源value并没改变 2.2 listlist：列表可以看作是个双端队列，可以在列表两端推入和弹出元素。 12345lpush key value: 将元素加入列表左表rpush key value：将元素加入列表右边lrange key start end ：范围获取lpop key： 删除列表最左边的元素，并将元素返回rpop key： 删除列表最右边的元素，并将元素返回 2.3 hashhash：Redis中的散列可以让用户将多个键值对存储到一个Redis键中 1234存储： hset key field value获取： hget key field获取所有的field和value： hgetall key删除： hdel key field 2.4 setset ： 不允许重复元素，集合最显著的特点应该就是其中的元素互不相同。 123存储：sadd key value获取：smembers key:获取set集合中所有元素删除：srem key value:删除set集合中的某个元素 2.5 sortedsetsortedset：有序集合类型，不允许重复元素，且元素有顺序 123存储：zadd key score value获取：zrange key start end [withscores]删除：zrem key value 三.redis持久化3.1 RDB在默认情况下，Redis将内存数据库快照保存到dump.rdb的二进制文件中。可以对Redis进行设置，让它在“N秒内数据集至少有N个改动”， 这一条件被满足时，自动保存一次数据集。比如说：让Redis满足“60秒内至少有1000个键被改动”这一个条件时，自动保存一次数据集。 3.2 AOF开启AOF持久化appendonly yes appendfsync always：每次有新命令追加到aof文件时就执行一个持久化，非常慢但是安全appendfsync everysec：每秒执行一次持久化，足够快（和使用rdb持久化差不多）并且在故障时只会丢失1秒钟的数据appendfsync no：从不持久化，将数据交给操作系统来处理。redis处理命令速度加快但是不安全。 四.JavaWeb连接核心代码 1234567891011@ResponseBody@RequestMapping(\"/list\")public Object listUser() &#123; if (null != redisUtil.get(\"user\")) &#123; return redisUtil.get(\"user\"); &#125; List&lt;User&gt; userList = userService.list(); String userStr = JSONObject.toJSONString(userList); redisUtil.set(\"user\", userStr, 10); return userStr;&#125; 可以看到已经set了： 10s内，再次请求时，是从缓存中获取的数据： 代码：链接：https://pan.baidu.com/s/1D-RJynE1zsjoWkvV5JBpwg提取码：lqhg","categories":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"keywords":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"ActiveMQ","slug":"middleware/1","date":"2020-05-08T13:54:40.624Z","updated":"2020-05-24T15:14:53.464Z","comments":true,"path":"middleware/1.html","link":"","permalink":"http://atwangjian.cn/middleware/1.html","excerpt":"","text":"一.简介1.1 JMS简介JMS即Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。 JMS是一种与厂商无关的 API，用来访问收发系统消息，它类似于JDBC(Java Database Connectivity)。这里，JDBC 是可以用来访问许多不同关系数据库的 API，而 JMS 则提供同样与厂商无关的访问方法，以访问消息收发服务。许多厂商都支持 JMS，包括 IBM 的 MQSeries、BEA的 Weblogic JMS service和 Progress 的 SonicMQ。 JMS 使您能够通过消息收发服务（有时称为消息中介程序或路由器）从一个 JMS 客户机向另一个 JMS客户机发送消息。消息是 JMS 中的一种类型对象，由两部分组成：报头和消息主体。报头由路由信息以及有关该消息的元数据组成。消息主体则携带着应用程序的数据或有效负载。根据有效负载的类型来划分，可以将消息分为几种类型，它们分别携带：简单文本(TextMessage)、可序列化的对象 (ObjectMessage)、属性集合 (MapMessage)、字节流 (BytesMessage)、原始值流 (StreamMessage)，还有无有效负载的消息 (Message)。 1.2 ActiveMQ简介Apache ActiveMQ是Apache软件基金会所研发的开放源代码消息中间件；由于ActiveMQ是一个纯Java程序，因此只需要操作系统支持Java虚拟机，ActiveMQ便可执行。 1.3 ActiveMQ启动和运行主页：http://activemq.apache.org/目前最新版本：5.15.12 (March 9, 2020)开发包及源码下载地址：http://activemq.apache.orgactivemq-5111-release.htmActiveMQ服务启动地址：http://127.0.0.1:8161/admin/用户名/密码：admin/admin 二.ActiveMQ点对点消息实现2.1 直接 Receive 方式Session.AUTO_ACKNOWLEDGE。当客户成功的从receive方法返回的时候，或者从MessageListener.onMessage方法成功返回的时候，会话自动确认客户收到的消息。Session.CLIENT_ACKNOWLEDGE。 客户通过消息的 acknowledge 方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消 费的消息。例如，如果一个消息消费者消费了 10 个消息，然后确认第 5 个消息，那么所有 10 个消息都被确认。Session.DUPS_ACKNOWLEDGE。 该选择只是会话迟钝第确认消息的提交。如果 JMS provider 失败，那么可能会导致一些重复的消息。如果是重复的消息，那么 JMS provider 必须把消息头的 JMSRedelivered 字段设置为 true。 生产者： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687 package main.activeMq; import org.apache.activemq.ActiveMQConnection; import org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.MessageProducer; import javax.jms.Session; import javax.jms.TextMessage; /** * 消息生产者 * * @author wangjian * @date 2020/5/8 22:26 */ public class Producer &#123; // 默认的用户名，密码，连接地址 private static final String USERNAME = ActiveMQConnection.DEFAULT_USER; private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD; private static final String URL = ActiveMQConnection.DEFAULT_BROKER_URL; // 发送消息数量 private static final int SENDNUM = 10; public static void main(String[] args) &#123; ConnectionFactory connectionFactory; // 连接工厂 Connection connection = null; // 连接 Session session; // 会话：接收或者发送消息的线程 Destination destination; // 消息的目的地 MessageProducer messageProducer; // 消息生产者 // 实例化连接工厂(URL:failover://tcp://localhost:61616) connectionFactory = new ActiveMQConnectionFactory(Producer.USERNAME, Producer.PASSWORD, Producer.URL); try &#123; // 通过连接工厂获取连接 connection = connectionFactory.createConnection(); // 启动 connection.start(); // 创建session,true:开启事务 session = connection.createSession(true, SENDNUM); // 创建消息队列 destination = session.createQueue(\"firstQueue\"); // 点对点 // destination = session.createTopic(\"firstTopic\"); // 发布订阅 // 创建消息生产者 messageProducer = session.createProducer(destination); sendMessage(session, messageProducer); session.commit(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; connection.close(); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; /** * 发送消息 * * @param session * @param producer */ public static void sendMessage(Session session, MessageProducer producer) &#123; for (int i = 0; i &lt; SENDNUM; i++) &#123; try &#123; TextMessage textMessage = session.createTextMessage(\"ActiveMQ 发送的消息：\" + i); System.out.println(\"发送消息：\" + \"ActiveMQ 发送的消息\" + i); producer.send(textMessage); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125;**消费者**： package main.activeMq; import org.apache.activemq.ActiveMQConnection; import org.apache.activemq.ActiveMQConnectionFactory; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.MessageConsumer; import javax.jms.Session; import javax.jms.TextMessage; /** * 消费者 * * @author wangjian * @date 2020/5/8 22:53 */ public class Consumer { // 默认的用户名，密码，连接地址 private static final String USERNAME = ActiveMQConnection.DEFAULT_USER; private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD; private static final String URL = ActiveMQConnection.DEFAULT_BROKER_URL; public static void main(String[] args) { ConnectionFactory connectionFactory; // 连接工厂 Connection connection = null; // 连接 Session session; // 会话：接收或者发送消息的线程 Destination destination; // 消息的目的地 MessageConsumer messageConsumer; // 消息消费者 // 实例化连接工厂 connectionFactory = new ActiveMQConnectionFactory(Consumer.USERNAME, Consumer.PASSWORD, Consumer.URL); try { // 创建连接 connection = connectionFactory.createConnection(); // 启动连接 connection.start(); // 创建session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); destination = session.createQueue(&quot;firstQueue&quot;); MessageConsumer sessionConsumer = session.createConsumer(destination); while (true) { TextMessage textMessage = (TextMessage) sessionConsumer.receive(); if (textMessage != null) { System.out.println(&quot;收到的消息:&quot; + textMessage.getText()); } else { break; } } } catch (JMSException e) { e.printStackTrace(); } } }2.2 使用 Listener 监听方式Listener监听： {% codeblock %} package main.activeMq; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageListener; import javax.jms.TextMessage; /** * 消息监听 * * @author wangjian * @date 2020/5/8 23:01 */ public class Listener implements MessageListener { @Override public void onMessage(Message message) { try { System.out.println(\"收到的消息：\" + ((TextMessage) message).getText()); } catch (JMSException e) { e.printStackTrace(); } } } {% endcodeblock %} 消费者： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package main.activeMq;import org.apache.activemq.ActiveMQConnection;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.Connection;import javax.jms.ConnectionFactory;import javax.jms.Destination;import javax.jms.JMSException;import javax.jms.MessageConsumer;import javax.jms.Session;/** * 消费者：监听方式 * @author wangjian * @date 2020/5/8 23:03 */public class Consumer2 &#123; // 默认的用户名，密码，连接地址 private static final String USERNAME = ActiveMQConnection.DEFAULT_USER; private static final String PASSWORD = ActiveMQConnection.DEFAULT_PASSWORD; private static final String URL = ActiveMQConnection.DEFAULT_BROKER_URL; public static void main(String[] args) &#123; ConnectionFactory connectionFactory; // 连接工厂 Connection connection = null; // 连接 Session session; // 会话：接收或者发送消息的线程 Destination destination; // 消息的目的地 MessageConsumer messageConsumer; // 消息消费者 // 实例化连接工厂 connectionFactory = new ActiveMQConnectionFactory(Consumer2.USERNAME, Consumer2.PASSWORD, Consumer2.URL); try &#123; // 创建连接 connection = connectionFactory.createConnection(); // 启动连接 connection.start(); // 创建session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); // 创建消息的连接队列 destination = session.createQueue(\"firstQueue\"); // 创建消息消费者 MessageConsumer sessionConsumer = session.createConsumer(destination); // 注册消息监听 sessionConsumer.setMessageListener(new Listener()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 三.ActiveMQ 发布-订阅消息模式实现必须先订阅，后发布 12destination = session.createTopic(\"firstTopic\"); // 发布订阅","categories":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"tags":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}],"keywords":[{"name":"中间件","slug":"中间件","permalink":"http://atwangjian.cn/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"}]},{"title":"Lambda表达式","slug":"java/2","date":"2020-05-07T15:44:12.443Z","updated":"2020-05-08T15:40:11.677Z","comments":true,"path":"java/2.html","link":"","permalink":"http://atwangjian.cn/java/2.html","excerpt":"","text":"简介为什么使用Lambda表达式：Lambda 是一个匿名函数，我们可以把 Lambda 表达式理解为是一段可以传递的代码（将代码像数据一样进行传递）。使用它可以写出更简洁、更灵活的代码。作为一种更紧凑的代码风格，使Java的语言表达能力得到了提升。 Lambda 表达式：在Java 8 语言中引入的一种新的语法元素和作符。这个操作符为 “-&gt;” ， 该操作符被称为 Lambda 操作或箭头操作符。它将 Lambda 分为两个部分：左侧：指定了 Lambda 表达式需要的参数列表右侧：指定了 Lambda 体，是抽象方法的实现逻辑，也即Lambda 表达式要执行的功 类型推断：Lambda 表达式中的参数类型都是由编译器推断得出的。Lambda 表达式中无需指定类型，程序依然可以编译，这是因为 javac 根据程序的上下文，在后台推断出了参数的类型。Lambda 表达式的类型依赖于上下文环境，是由编译器推断出来的。这就是所谓的“类型推断”。 三.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185package main.java8;import org.junit.Test;import java.util.ArrayList;import java.util.Comparator;import java.util.function.Consumer;/** * Lambda表达式的使用 * * 1.举例： (o1,o2) -&gt; Integer.compare(o1,o2); * 2.格式： * -&gt; :lambda操作符 或 箭头操作符 * -&gt;左边：lambda形参列表 （其实就是接口中的抽象方法的形参列表） * -&gt;右边：lambda体 （其实就是重写的抽象方法的方法体） * * 3. Lambda表达式的使用：（分为6种情况介绍） * * 总结： * -&gt;左边：lambda形参列表的参数类型可以省略(类型推断)；如果lambda形参列表只有一个参数，其一对()也可以省略 * -&gt;右边：lambda体应该使用一对&#123;&#125;包裹；如果lambda体只有一条执行语句（可能是return语句），省略这一对&#123;&#125;和return关键字 * * 4.Lambda表达式的本质：作为函数式接口的实例 * * 5. 如果一个接口中，只声明了一个抽象方法，则此接口就称为函数式接口。我们可以在一个接口上使用 @FunctionalInterface 注解， * 这样做可以检查它是否是一个函数式接口。 * * 6. 所以以前用匿名实现类表示的现在都可以用Lambda表达式来写。 * @author wangjian * @date 2020/5/7 23:38 */public class LambdaTest &#123; //语法格式一：无参，无返回值 @Test public void test1() &#123; Runnable r1 = new Runnable() &#123; @Override public void run() &#123; System.out.println(\"我爱北京天安门\"); &#125; &#125;; r1.run(); System.out.println(\"***********************\"); Runnable r2 = () -&gt; &#123; System.out.println(\"我爱北京故宫\"); &#125;; r2.run(); &#125; //语法格式二：Lambda 需要一个参数，但是没有返回值。 @Test public void test2() &#123; Consumer&lt;String&gt; con = new Consumer&lt;String&gt;() &#123; @Override public void accept(String s) &#123; System.out.println(s); &#125; &#125;; con.accept(\"谎言和誓言的区别是什么？\"); System.out.println(\"*******************\"); Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(\"一个是听得人当真了，一个是说的人当真了\"); &#125; //语法格式三：数据类型可以省略，因为可由编译器推断得出，称为“类型推断” @Test public void test3() &#123; Consumer&lt;String&gt; con1 = (String s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(\"一个是听得人当真了，一个是说的人当真了\"); System.out.println(\"*******************\"); Consumer&lt;String&gt; con2 = (s) -&gt; &#123; System.out.println(s); &#125;; con2.accept(\"一个是听得人当真了，一个是说的人当真了\"); &#125; @Test public void test4() &#123; ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();//类型推断 int[] arr = &#123;1, 2, 3&#125;;//类型推断 &#125; //语法格式四：Lambda 若只需要一个参数时，参数的小括号可以省略 @Test public void test5() &#123; Consumer&lt;String&gt; con1 = (s) -&gt; &#123; System.out.println(s); &#125;; con1.accept(\"一个是听得人当真了，一个是说的人当真了\"); System.out.println(\"*******************\"); Consumer&lt;String&gt; con2 = s -&gt; &#123; System.out.println(s); &#125;; con2.accept(\"一个是听得人当真了，一个是说的人当真了\"); &#125; //语法格式五：Lambda 需要两个或以上的参数，多条执行语句，并且可以有返回值 @Test public void test6() &#123; Comparator&lt;Integer&gt; com1 = new Comparator&lt;Integer&gt;() &#123; @Override public int compare(Integer o1, Integer o2) &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2); &#125; &#125;; System.out.println(com1.compare(12, 21)); System.out.println(\"*****************************\"); Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; &#123; System.out.println(o1); System.out.println(o2); return o1.compareTo(o2); &#125;; System.out.println(com2.compare(12, 6)); &#125; //语法格式六：当 Lambda 体只有一条语句时，return 与大括号若有，都可以省略 @Test public void test7() &#123; Comparator&lt;Integer&gt; com1 = (o1, o2) -&gt; &#123; return o1.compareTo(o2); &#125;; System.out.println(com1.compare(12, 6)); System.out.println(\"*****************************\"); Comparator&lt;Integer&gt; com2 = (o1, o2) -&gt; o1.compareTo(o2); System.out.println(com2.compare(12, 21)); &#125; @Test public void test8() &#123; Consumer&lt;String&gt; con1 = s -&gt; &#123; System.out.println(s); &#125;; con1.accept(\"一个是听得人当真了，一个是说的人当真了\"); System.out.println(\"*****************************\"); Consumer&lt;String&gt; con2 = s -&gt; System.out.println(s); con2.accept(\"一个是听得人当真了，一个是说的人当真了\"); &#125; &#125;","categories":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/categories/java8/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/tags/java8/"}],"keywords":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/categories/java8/"}]},{"title":"多线程","slug":"java/3","date":"2020-04-23T13:08:57.002Z","updated":"2020-07-01T15:25:43.787Z","comments":true,"path":"java/3.html","link":"","permalink":"http://atwangjian.cn/java/3.html","excerpt":"","text":"一.基本概念1.1 程序，进程和线程程序（program)是为了完成特定任务，用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象。进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期如：运行中的QQ，运行中的MP3播放器●程序是静态的，进程是动态的●进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。●若一个进程同一时间并行执行多个线程，就是支持多线程的●线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小●一个进程中的多个线程共享相同的内存单元/内存地址空间它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 1.2 单核CPU和多核CPU●单核CPU其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。●如果是多核的话，才能更好的发挥多线程的效率。（现在的服务器都是多核的）●一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程 1.3 并行和并发并行：多个CPU同时执行多个任务。比如：多个人同时做不同的事。并发：一个CPU(采用时间片)“同时”执行多个任务。比如：秒杀、多个人做同一件事。 1.4 多线程优点以单核CPU为例，只使用单个线程先后完成多个任务（调用多个方法），肯定比用多个线程来完成用的时间更短，为何仍需多线程呢？多线程程序的优点： 提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 1.5 何时需要多线程●程序需要同时执行两个或多个任务。●程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等。 二.线程的创建和使用2.1 继承Thread类●Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。Thread类的特性：●每个线程都是通过某个特定Thread对象的run()方法来完成操作的，经常把run()方法的主体称为线程体●通过该Thread对象的start()方法来启动这个线程，而非直接调用run 2.1.1 流程（1）定义子类继承Thread类。（2）子类中重写Thread类中的run方法。（3）创建Thread子类对象，即创建了线程对象。（4）调用线程对象start方法：启动线程，调用run方法。 2.1.2 注意点（1）如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。（2） run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。（3）想要启动多线程，必须调用start方法。（4）一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。 2.1.3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package main.javabasic.thread;/** * 创建多线程的方式一：继承Thread类 * 1.定义子类继承Thread类。 * 2.子类中重写Thread类中的run方法。 * 3.创建Thread子类对象，即创建了线程对象。 * 4.调用线程对象start方法：启动线程，调用run方法：(1)启动当前线程 （2）调用当前线程的run() * * @author wangjian * @date 2020/4/20 22:24 */class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 1; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; &#125;&#125;public class ThreadTest1 &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); // 问题一：我们不能通过直接调用run()的方式启动线程 // myThread.run(); // 问题二：再启动一个线程:不可以还让已经start()的线程去执行 // if (threadStatus != 0) throw new IllegalThreadStateException(); // myThread.start(); // 我们需要重新创建一个线程的对象 MyThread myThread2 = new MyThread(); myThread2.start(); // 以下方法仍然是在main线程中执行的 for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(Thread.currentThread().getName() + \":\" + i + \"===========mian()=======\"); &#125; &#125; &#125;&#125; 2.2 实现Runnable接口2.2.1 流程（1）定义子类，实现Runnable接口。（2）子类中重写Runnable接口中的run方法。（3）通过Thread类含参构造器创建线程对象。（4）将Runnable接口的子类对象作为实际参数传递给Thread类的构造器中。（5）调用Thread类的start方法：开启线程，调用Runnable子类接口的run方法。 2.2.2 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package main.javabasic.thread;/** * 创建多线程的方式二：实现Runnable接口 * 1.创建一个实现了Runnable接口的类 * 2.实现类去实现Runnable中的抽象方法：run() * 3.创建实现类的对象 * 4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 * 5.通过Thread类的对象调用start() * * 比较创建线程的两种方式： * 开发中优先选择实现Runnable接口的方式 * 原因：1.实现的方式没有类的单继承性的局限性 * 2.实现的方式更适合处理多个线程有共享数据的情况 * 联系：public class Thread implements Runnable * 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run()中 * * @author wangjian * @date 2020/4/21 22:45 */class Mythread3 implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; &#125;&#125;public class ThreadTest2 &#123; public static void main(String[] args) &#123; Mythread3 mythread3 = new Mythread3(); Thread t1 = new Thread(mythread3); t1.setName(\"线程1\"); // 通过Thread类的对象调用start()：启动线程；调用当前线程的run方法—&gt;调用了Runnable类型的target的run() t1.start(); Thread.currentThread().setName(\"主线程\"); for (int i = 0; i &lt; 100; i++) &#123; if (i % 2 != 0) &#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; &#125;&#125; 2.3 实现Callable接口2.4 线程池2.4.1 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445package main.javabasic.thread.create;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ThreadPoolExecutor;/** * 创建多线程方式四：使用线程池 * 好处：1.提高响应速度（减少了创建新线程的时间） * 2.降低资源消耗（重复利用线程池中线程，不需要每次都创建） * 3.便于线程管理： * corePoolSize:核心池的大小 * maximumPoolSize:最大线程数 * keepAliveTime:线程没有任务时最多保持多长时间后会终止 * * @author wangjian * @date 2020/5/7 22:37 */class NumberThread implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt;= 100; i++) &#123; if (i % 2 == 0) &#123; System.out.println(Thread.currentThread().getName() + \":\" + i); &#125; &#125; &#125;&#125;public class ThreadPoolTest &#123; public static void main(String[] args) &#123; // 1.提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); // 2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象 ThreadPoolExecutor service1 = (ThreadPoolExecutor) service; //service1.setCorePoolSize(15); // System.out.println(service.getClass()); service.execute(new NumberThread()); // 适合使用于Runnable // service.submit(Callable callable); // 适合使用于Callable // 关闭连接池 service.shutdown(); &#125;&#125; 2.5 Thread类的有关方法●void start(): 启动线程，并执行对象的run()方法●run(): 线程在被调度时执行的操作●String getName(): 返回线程的名称●void setName(String name):设置该线程名称●static Thread currentThread(): 返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类●static void yield()：线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若队列中没有同优先级的线程，忽略此方法●join() ：当某个程序执行流中调用其他线程的 join() 方法时，调用线程将被阻塞，直到 join() 方法加入的 join 线程执行完为止●低优先级的线程也可以获得执行●static void sleep(long millis)：(指定时间:毫秒) 令当前活动线程在指定时间段内放弃对CPU控制,使其他线程有机会被执行,时间到后重排队。 抛出InterruptedException异常●stop(): 强制线程生命期结束，不推荐使用●boolean isAlive()：返回boolean，判断线程是否还活着 三.线程的生命周期JDK中用Thread.State类定义了线程的几种状态要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：●新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态●就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源●运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能●阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态●死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 四.线程的同步4.1 同步问题123456789101112131415161718192021222324252627282930313233343536373839404142package main.javabasic.duoxiancheng;/** * @author wangjian * @date 2020/6/28 21:42 */class Ticket implements Runnable &#123;private int ticket = 100;@Overridepublic void run() &#123; while (true) &#123; if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"售出车票,ticket号为：\" + ticket--); &#125; else &#123; break; &#125; &#125;&#125;&#125;public class TicketDemo &#123;public static void main(String[] args) &#123; Ticket t = new Ticket(); Thread t1 = new Thread(t); Thread t2 = new Thread(t); Thread t3 = new Thread(t); t1.setName(\"t1窗口\"); t2.setName(\"t2窗口\"); t3.setName(\"t3窗口\"); t1.start(); t2.start(); t3.start();&#125;&#125; 1.多线程出现了安全问题2.问题的原因：当多条语句在操作同一个线程共享数据时，一个线程对多条语句只执行了一部分，还没有执行完，另一个线程参与进来执行。导致共享数据错误。3.解决方法：对多条操作共享数据的语句，只能让一个线程都执行完，在执行的过程中，其他线程不可以参与执行。 4.2 解决线程安全问题Java对于多线程的安全问题提供了专业的解决方式：同步机制 4.2.1 Synchronized同步代码块同步代码块synchronized (对象){ // 需要被同步的代码;} （1）同步代码块解决继承Thread类的线程安全问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package main.javabasic.thread.security;/** * 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器 * * @author wangjian * @date 2020/4/29 22:16 */class Window2 extends Thread &#123; private static int ticket = 100; // static保证对象唯一 private static Object obj = new Object(); @Override public void run() &#123; while (true) &#123; // synchronized (obj) &#123; synchronized (Window2.class) &#123; // 类也是对象，Window2只会加载一次 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(getName() + \":卖票，票号为\" + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125;&#125;public class WindowTest2 &#123; public static void main(String[] args) &#123; Window2 t1 = new Window2(); Window2 t2 = new Window2(); Window2 t3 = new Window2(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; （2）同步代码块解决实现Runable接口的线程安全问题 1234567891011121314151617181920212223242526272829303132333435363738394041class Window implements Runnable &#123; private int ticket = 100; Object obj = new Object(); @Override public void run() &#123; while (true) &#123; // synchronized (obj) &#123; synchronized (this) &#123; // 此时的this,指的是唯一的window1的对象 if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \":卖票\" + ticket); ticket--; &#125; &#125; &#125; &#125;&#125;public class WindowTest1 &#123; public static void main(String[] args) &#123; Window window = new Window(); Thread window1 = new Thread(window); Thread window2 = new Thread(window); Thread window3 = new Thread(window); window1.setName(\"窗口1\"); window2.setName(\"窗口2\"); window3.setName(\"窗口3\"); window1.start(); window2.start(); window3.start(); &#125;&#125; 4.2.2 Synchronized同步方法同步方法synchronized还可以放在方法声明中，表示整个方法为同步方法。例如：public synchronized void show (String name){ ….} （1）同步方法解决继承Thread类的线程安全问题 1234567891011121314151617181920212223242526272829303132333435363738394041class Window4 extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private static synchronized void show() &#123; // 同步监视器：Window4.class if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \":卖票，票号为\" + ticket); ticket--; &#125; &#125;&#125;public class WindowTest4 &#123; public static void main(String[] args) &#123; Window4 t1 = new Window4(); Window4 t2 = new Window4(); Window4 t3 = new Window4(); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; （2）同步方法解决实现Runable接口的线程安全问题 1234567891011121314151617181920212223242526272829303132333435363738class Window3 implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); &#125; &#125; private synchronized void show() &#123; // 同步监视器this if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \":卖票\" + ticket); ticket--; &#125; &#125;&#125;public class WindowTest3 &#123; public static void main(String[] args) &#123; Window3 window = new Window3(); Thread window1 = new Thread(window); Thread window2 = new Thread(window); Thread window3 = new Thread(window); window1.setName(\"窗口1\"); window2.setName(\"窗口2\"); window3.setName(\"窗口3\"); window1.start(); window2.start(); window3.start(); &#125;&#125; 4.2.3 Lock锁12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Window5 implements Runnable &#123; private int ticket = 100; // 1.实例化ReentrantLock ReentrantLock lock = new ReentrantLock(); @Override public void run() &#123; while (true) &#123; try &#123; // 2.启动锁 lock.lock(); if (ticket &gt; 0) &#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \",售票号：\" + ticket); ticket--; &#125; else &#123; break; &#125; &#125; finally &#123; // 3.结束锁 lock.unlock(); &#125; &#125; &#125;&#125;public class LockTest &#123; public static void main(String[] args) &#123; Window5 window = new Window5(); Thread t1 = new Thread(window); Thread t2 = new Thread(window); Thread t3 = new Thread(window); t1.setName(\"窗口1\"); t2.setName(\"窗口2\"); t3.setName(\"窗口3\"); t1.start(); t2.start(); t3.start(); &#125;&#125; 4.3 同步机制中的锁同步机制锁在《Thinking in Java》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。防止这种冲突的方法，就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。synchronized的锁是什么？●任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。●同步方法的锁：静态方法（类名.class）、非静态方法（this）●同步代码块：自己指定，很多时候也是指定为this或类名.class 注意：●必须确保使用同一个资源的多个线程共用一把锁，这个非常重要，否则就无法保证共享资源的安全●一个线程类中的所有静态方法共用同一把锁（类名.class），所有非静态方法共用同一把锁（this），同步代码块（指定需谨慎） 4.4 同步的范围1、如何找问题，即代码是否存在线程安全？（非常重要）（1）明确哪些代码是多线程运行的代码（2）明确多个线程是否有共享数据（3）明确多线程运行代码中是否有多条语句操作共享数据2、如何解决呢？（非常重要）对多条操作共享数据的语句，只能让一个线程都执行完，在执行过程中，其他线程不可以参与执行。即所有操作共享数据的这些语句都要放在同步范围中3、切记：●范围太小：没锁住所有有安全问题的代码●范围太大：没发挥多线程的功能。 4.5 释放锁的操作●当前线程的同步方法、同步代码块执行结束。●当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行。●当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束。●当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁。 4.6 不会释放锁的操作●线程执行同步代码块或同步方法时，程序调用Thread.sleep()、Thread.yield()方法暂停当前线程的执行●线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）。●应尽量避免使用suspend()和resume()来控制线程","categories":[{"name":"java","slug":"java","permalink":"http://atwangjian.cn/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://atwangjian.cn/tags/java/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://atwangjian.cn/categories/java/"}]},{"title":"Java系统定制","slug":"others","date":"2020-04-19T13:50:05.795Z","updated":"2020-04-19T14:42:12.549Z","comments":true,"path":"others.html","link":"","permalink":"http://atwangjian.cn/others.html","excerpt":"","text":"服务范围我们团队（我一个人）可以根据用户的功能要求，量身定制Java系统设计程序。需要用户提供详细的功能要求。联系本站客服QQ：876027276给我发消息告知。我们会根据用户系统的难易程度，工作量大小等，具体的给出一个报价。价格协商一致过后，付下40%定金。我们开始开发（中途可以联系我们查看进度）。做好过后先发送设计桌面演示录像，用户看后满意付尾款，我们再发程序源码压缩包。 售后服务包指导配置环境，远程调试运行一次，在用户自己电脑上面运行起来。 示例商城系统","categories":[],"tags":[],"keywords":[]},{"title":"一头扎进强大的Stream Api","slug":"java/1","date":"2020-04-18T13:02:27.038Z","updated":"2020-04-19T13:48:09.044Z","comments":true,"path":"java/1.html","link":"","permalink":"http://atwangjian.cn/java/1.html","excerpt":"","text":"写在前面：为啥要学Java8？我不管java8有多牛逼，只要是项目用了jdk1.8，就会有程序员用java8的语法写代码，所有我的理由很简单：为了看懂别人写的代码。 一.一头扎进Stream1.1 啥是Stream1.Stream API ( java.util.stream) 把真正的函数式编程风格引入到是目前为止对Java类库最好的补充，因为Stream API可以极大序员的生产力，让程序员写出高效率、干净、简洁的代码。2.Stream 是 Java8 中处理集合的关键抽象概念，它可以指定你希望对集合进行的操作，可以执行非常复杂的查找、过滤和映射数据等操作。 使用Stream API 对集合数据进行操作类似于使用 SQL 执行的数据库查询。也可以使用 Stream API 来并行执行操作。简言之，Stream API 提供了一种高效且易于使用的处理数据的方式。 1.2 特点1.Stream 和 Collection 集合的区别：Collection 是一种静态的内存数据结构，而 Stream 是有关计算的。前者是主要面向内存，存储在内存中，后者主要是面向 CPU，通过 CPU 实现计算2.Stream关注的是对数据的运算，与CPU打交道,集合关注的是对数据的存储，与内存打交道3.（1）Stream 自己不会存储元素 （2）Stream 不会改变源对象。相反，他们会返回一个持有结果的新Stream （3）Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行4.Stream执行流程:(1)Stream的实例化(2)一系列的中间操作（过滤，映射……）(3)终止操作 二.Stream操作三步骤2.1 创建 Stream的方式（1）通过集合Java8 中的 Collection 接口被扩展，提供了两个获取流的方法：●default Stream stream() : 返回一个顺序流●default Stream parallelStream() : 返回一个并行流 （2）通过数组Java8 中的 Arrays 的静态方法 stream() 可以获取数组流：●static Stream stream(T[] array): 返回一个流重载形式，能够处理对应基本类型的数组：●public static IntStream stream(int[] array)●public static LongStream stream(long[] array)●public static DoubleStream stream(double[] array) （3）通过Stream的of() 可以调用Stream类静态方法 of(), 通过显示值创建一流。它可以接收任意数量的参数。●public static Stream of(T… values) : 返回一个流 （4）创建无限流可以使用静态方法 Stream.iterate() 和 Stream.generate(), 创建无限流。●迭代public static Stream iterate(final T seed, final UnaryOperator f)●生成public static Stream generate(Supplier s) 2.2 中间操作多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理！而在终止操作时一次性全部处理，称为“惰性求值”。(1)筛选与切片 方法 描述 filter(Predicate p) 接收 Lambda ， 从流中排除某些元素 distinct() 筛选，通过流所生成元素的 hashCode() 和 equals() 去除重复元素 limit(long maxSize) 截断流，使其元素不超过给定数量 skip(long n) 跳过元素，返回一个扔掉了前 n 个元素的流。若流中元素不足 n 个，则返回一个空流。与 limit(n) 互补 （2）映射 方法 描述 map(Function f) 接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素。 mapToDouble(ToDoubleFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 DoubleStream。 mapToInt(ToIntFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 IntStream。 mapToLong(ToLongFunction f) 接收一个函数作为参数，该函数会被应用到每个元素上，产生一个新的 LongStream。 flatMap(Function f) 接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 （3）排序 方法 描述 sorted() 产生一个新流，其中按自然顺序排序 sorted(Comparator com) 产生一个新流，其中按比较器顺序 2.3 终止操作●终端操作会从流的流水线生成结果。其结果可以是任何不是流的值，例如：List、Integer，甚至是 void 。●流进行了终止操作后，不能再次使用。（1）匹配与查找 方法 描述 allMatch(Predicate p) 检查是否匹配所有元素 anyMatch(Predicate p) 检查是否至少匹配一个元素 noneMatch(Predicate p) 检查是否没有匹配所有元素 findFirst() 返回第一个元素 findAny() 返回当前流中的任意 count() 返回流中元素总数 max(Comparator c) 返回流中最大值 min(Comparator c) 返回流中最小值 forEach(Consumer c)/td> 内部迭代 （2）归约 方法 描述 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional 备注：map 和 reduce 的连接通常称为 map-reduce 模式，因 Google用它来进行网络搜索而出名。 （3）收集 方法 描述 collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 Collector 接口中方法的实现决定了如何对流执行收集的操作(如收集到 List、Set、Map)。 另外， Collectors 实用类提供了很多静态方法，可以方便地创建常见收集器实例。 三.代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package main.java8;import main.entity.User;import org.junit.Test;import javax.sound.midi.Soundbank;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;import java.util.List;import java.util.Optional;import java.util.Set;import java.util.stream.Collectors;import java.util.stream.IntStream;import java.util.stream.Stream;/*** @author wangjian* @date 2020/4/15 21:40*/public class StreamTest &#123; @Test public void test1() &#123; // 1.通过集合 List&lt;User&gt; list = User.getUserList(); // 1.1 顺序流 Stream&lt;User&gt; stream = list.stream(); // 1.2 并行流 Stream&lt;User&gt; userStream = list.parallelStream(); // 2. 通过数组 int[] ints = new int[]&#123;1, 2, 3, 4, 5&#125;; IntStream intStream = Arrays.stream(ints); User u1 = new User(11, \"firse\", \"123465\"); User u2 = new User(12, \"secong\", \"sdfasdf\"); User[] users = new User[]&#123;u1, u2&#125;; Stream&lt;User&gt; userStream1 = Arrays.stream(users); // 3. 通过Stream的of() Stream&lt;Integer&gt; integerStream = Stream.of(1, 2, 3, 4, 5, 6); // 4. 创建无限流 // 4.1 迭代 Stream.iterate(0, t -&gt; t + 2).limit(10).forEach(System.out::println); // 4.2 生成 Stream.generate(Math::random).limit(10).forEach(System.out::println); &#125; /** * 中间操作 */ @Test public void test2() &#123; System.out.println(\"========1.筛选与切片============\"); // 1.筛选与切片 List&lt;User&gt; list = User.getUserList(); // 1.1 filter(Predicate p)，接收Lambda，从流中排除某些元素。查询id大于5的数据 list.stream().filter(e -&gt; e.getId() &gt; 5).forEach(System.out::println); System.out.println(); // 1.2 limit(n)，截断流，使其元素不超过给定数量 list.stream().limit(5).forEach(System.out::println); System.out.println(); // 1.3 skip(n)，跳过元素，返回一个扔掉了前n个元素的流。若流中元素不足n个，则返回一个空流。 list.stream().skip(5).forEach(System.out::println); System.out.println(); // 1.4 distinct()，去重（通过流所生成元素的hashCode()和equals()去除重复元素） List list1 = new ArrayList(); list1.add(\"1\"); list1.add(\"2\"); list1.add(\"3\"); list1.add(\"1\"); System.out.println(\"当前list1:\" + list1); System.out.println(); list1.stream().distinct().forEach(System.out::println); // 2.映射 System.out.println(\"===========2.map映射============\"); list.add(new User(15, \"张三丰\", \"123456789\")); // 获取用户名长度大于3的用户名的姓名 list.stream().map(e -&gt; e.getUserName()).filter(userName -&gt; userName.length() &gt; 2).forEach(System.out::println); List&lt;String&gt; list2 = Arrays.asList(\"aa\", \"bb\", \"cc\", \"dd\"); list2.stream().map(e -&gt; e.toUpperCase()).forEach(System.out::println); // 3.排序 System.out.println(\"===========3.排序============\"); List&lt;Integer&gt; list3 = Arrays.asList(1, 2, 4, 63, 0, -5, 23, 1231); list3.stream().sorted().forEach(System.out::println); list.stream().sorted((e1, e2) -&gt; Integer.compare(e1.getId(), e2.getId())).forEach(System.out::println); System.out.println(\"排序多判断条件：\"); list.add(new User(15, \"李四\", \"123123\")); list.stream().sorted((e1, e2) -&gt; &#123; int idValue = Integer.compare(e1.getId(), e2.getId()); if (idValue != 0) &#123; return idValue; &#125; else &#123; return -Integer.compare(e1.getId(), e2.getId()); &#125; &#125;).forEach(System.out::println); &#125; @Test public void test3() &#123; // 1.匹配与查找 System.out.println(\"==============匹配与查找=============\"); // 1.1 allMatch(Predicate p) 检查是否匹配所有元素：是否所有的id都大于15 List&lt;User&gt; list = User.getUserList(); boolean allMatch = list.stream().allMatch(e -&gt; e.getId() &gt; 10); System.out.println(allMatch); // 1.2 anyMatch(Predicate p) 检查是否至少匹配一个元素 boolean anyMatch = list.stream().anyMatch(e -&gt; e.getId() == 11); System.out.println(anyMatch); // 1.3 noneMatch(Predicate p) 检查是否没有匹配所有元素 boolean noneMatch = list.stream().noneMatch(e -&gt; e.getId() &gt; 12); System.out.println(noneMatch); // 1.4 findFirst() 返回第一个元素 Optional&lt;String&gt; first = list.stream().map(e -&gt; e.getUserName()).findFirst(); System.out.println(first); // 1.5 findAny() 返回当前流中的任意元素 Optional&lt;String&gt; any = list.parallelStream().map(e -&gt; e.getUserName()).findAny(); System.out.println(any); // 1.6 count() 返回流中元素总数 long count = list.stream().count(); System.out.println(count); // 1.7 max(Comparator c) 返回流中最大值 Optional&lt;Integer&gt; max = list.stream().map(e -&gt; e.getId()).max(Integer::compare); System.out.println(max); // 1.8 min(Comparator c) 返回流中最小值 Optional&lt;Integer&gt; min = list.stream().map(e -&gt; e.getId()).min(Integer::compare); System.out.println(min); // 1.9 forEach(Consumer c),内部迭代(使用 Collection 接口需要用户去做迭代，称为外部迭代) list.stream().forEach(System.out::println); // 2. 归约 // 2.1 reduce(T iden, BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 T System.out.println(\"==============归约=============\"); // 计算1-10的自然数的和 List&lt;Integer&gt; list1 = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); Integer sum = list1.stream().reduce(0, Integer::sum); System.out.println(sum); // reduce(BinaryOperator b) 可以将流中元素反复结合起来，得到一个值。返回 Optional&lt;T&gt; // 计算所有id的和 Optional&lt;Integer&gt; idSum = list.stream().map(e -&gt; e.getId()).reduce(Integer::sum); System.out.println(idSum); Optional&lt;Integer&gt; idSum2 = list.stream().map(e -&gt; e.getId()).reduce((d1, d2) -&gt; d1 + d2); System.out.println(idSum2); // 3.收集 // collect(Collector c) 将流转换为其他形式。接收一个 Collector接口的实现，用于给Stream中元素做汇总的方法 System.out.println(\"============收集===========\"); List&lt;User&gt; idList = list.stream().filter(e -&gt; e.getId() &gt; 5).collect(Collectors.toList()); System.out.println(idList); Set&lt;User&gt; idSet = list.stream().filter(e -&gt; e.getId() &gt; 5).collect(Collectors.toSet()); System.out.println(idSet); &#125;&#125;","categories":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/categories/java8/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/tags/java8/"}],"keywords":[{"name":"java8","slug":"java8","permalink":"http://atwangjian.cn/categories/java8/"}]},{"title":"Spring事务","slug":"spring/1","date":"2020-04-08T14:36:07.841Z","updated":"2020-05-24T15:19:24.777Z","comments":true,"path":"spring/1.html","link":"","permalink":"http://atwangjian.cn/spring/1.html","excerpt":"","text":"一.事务的概念和特性概念：事务指的是逻辑上的一组操作，这个操作要么全部成功，要么全部失败。特性： 特性 描述 原子性 事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生 一致性 事务前后数据的完整性必须保持一致 隔离性 多个用户并发访问数据库时，一个用户的事务不能被其他用户的事务所干扰，多个并发事务之间数据要相互隔离 持久性 一个事务一旦被提交，它对数据库中数据的改变就是永久性的，即使数据库发生故障也不应该对其有任何影响 二.事务的APISpring事务管理高层抽象主要包括3个接口PlatformTransactionManager:事务管理器TransactionDefinition:事务定义信息（隔离，传播，超时，只读）TransactionStatus:事务具体运行状态 2.1 PlatformTransactionManagerSpring为不同的持久化框架提供了不同PlatformTransactionManager接口实现,该接口中提供了三个事务操作方法，具体如下。TransactionStatus getTransaction（TransactionDefinition definition）：用于获取事务状态信息。void commit（TransactionStatus status）：用于提交事务。void rollback（TransactionStatus status）：用于回滚事务。 事务 说明 org.springframework.jdbc.datasource.DataSourceTransactionManager 使用Spring JDBC或ibatis进行持久化数据时使用 org.springframework.orm.hibernate3.HibernateTransactionManager 使用Hibernate3.0版本进行持久化数据时使用 org.springframework.orm.jpa.JpaTransactionManager 使用JPA进行持久时使用 org.springframework.orm.jdo.JdoTransactionManager 当持久化机制是Jdo时使用 org.springframework.transaction.jta.JtaTransactionManager 使用一个JTA实现来管理事务，在一个事务跨越多个资源时必须使用 2.2 TransactionDefinitionTransactionDefinition 接口是事务定义（描述）的对象，它提供了事务相关信息获取的方法，其中包括五个操作，具体如下。String getName()：获取事务对象名称。int getIsolationLevel()：获取事务的隔离级别。int getPropagationBehavior()：获取事务的传播行为。int getTimeout()：获取事务的超时时间。boolean isReadOnly()：获取事务是否只读。 2.2.1 隔离级别 隔离级别 含义 DEFAULT 使用后端数据库默认的隔离级别（srping中的选择项） READ_UNCOMMITED 允许你读取还未提交的改变了的数据，可能导致脏，幻，不可重复读 READ_UNCOMMITTED 允许在并发事务已经提交后读取，可防止脏读，但幻读和不可重复读仍可发生 REPEATABLE_READ 对相同字段的多次读取时一致的，除非数据被事务本身改变，可防止脏，不可重复读，但幻读仍可能发生 SERIALIZABLE 完全服从ACID的隔离级别，确保不发生脏，幻，不可重复读。这在所有的隔离级别中是最低的，它是典型的通过完全锁定在事务中涉及的数据表来完成的 Mysql默认采用REPEATABLE_READ隔离级别，Oracle默认采用READ_COMMITTED隔离级别。 脏读：一个事务读取了另一个事务改写但还未提交的数据，如果这些数据被回滚，则读到的数据是无效的。不可重复读：在同一个事务中，多次读取同一数据返回的结果有所不同。幻读：一个事务读取了几行记录后，另一个事务插入一些记录，幻读就发生了。再后来的查询中，第一个事务就会发现有些原来没有的记录。 2.2.1 传播行为 事务传播行为类型 说明 PROPAGATION_REQUIRED 支持当前事务，假设当前没有事务。就新建一个事务） PROPAGATION_SUPPORTS 支持当前事务，假设当前没有事务，就以非事务方式运行 PROPAGATION_MANDATORY 支持当前事务，假设当前没有事务，就抛出异常 PROPAGATION_REQUIRES_NEW 新建事务，假设当前存在事务。把当前事务挂起 PROPAGATION_NOT_SUPPORTED 以非事务方式运行操作。假设当前存在事务，就把当前事务挂起 PROPAGATION_NEVER 以非事务方式运行，假设当前存在事务，则抛出异常 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 aaa,bbb的这2个操作是在一个事务里面的aaa,bbb的这2个操作不在一个事务里面的aaa执行完以后，设置一个保存点，当bbb发生异常以后，回滚到保存点或最初始状态 3.1 TransactionStatusTransactionStatus 接口是事务的状态，它描述了某一时间点上事务的状态信息。其中包含六个操作void flush() 刷新事务boolean hasSavepoint() 获取是否存在保存点boolean isCompleted() 获取事务是否完成boolean isNewTransaction() 获取是否是新事务boolean isRollbackOnly() 获取是否回滚void setRollbackOnly() 设置事务回滚 其他博客：https://blog.csdn.net/qq_38526573/article/details/87898161","categories":[{"name":"Spring","slug":"Spring","permalink":"http://atwangjian.cn/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://atwangjian.cn/tags/Spring/"}],"keywords":[{"name":"Spring","slug":"Spring","permalink":"http://atwangjian.cn/categories/Spring/"}]},{"title":"测试专用","slug":"test","date":"2020-04-05T12:25:25.429Z","updated":"2020-04-05T13:38:50.509Z","comments":true,"path":"test.html","link":"","permalink":"http://atwangjian.cn/test.html","excerpt":"","text":"一级目录testasdfasdfasddddddddddddddsdafdasfsdafasdfsdfsdafsdafdsf sdfsdf dsfsdafasdfasdf asdfasdfasddddddddddddddsdafdasfsdafasdfsdfsdafsdafdsf sdfsdf dsfasdfasdfasdf asdfasdfasddddddddddddddsdafdasfsdafasdfsdfsdafsdafdsf sdfsdf sdafasdfsasdfasdfasddddddddddddddsdafdasfsdafasdfsdfsdafsdafdsf sdfsdf 测试测试测试 位运算 符号 计算 按位与 &amp; 相同为1，不同为0 按位或 &#124; 有1则1 按位异或 ^ 相同为0，不同位1 按位取反 ~ 左移 &lt;&lt; 相当于乘以2^n^ 右移 &gt;&gt; 相当于除以2^n^ 无符号右移 &gt;&gt;&gt;","categories":[{"name":"测试","slug":"测试","permalink":"http://atwangjian.cn/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://atwangjian.cn/tags/%E6%B5%8B%E8%AF%95/"}],"keywords":[{"name":"测试","slug":"测试","permalink":"http://atwangjian.cn/categories/%E6%B5%8B%E8%AF%95/"}]},{"title":"Java工具类","slug":"tools","date":"2020-04-03T09:16:21.000Z","updated":"2020-05-24T15:00:48.149Z","comments":false,"path":"tools.html","link":"","permalink":"http://atwangjian.cn/tools.html","excerpt":"","text":"一.String字符串1.对字符串去除符号并转为json123456789101112131415public static void removeSymbol() &#123; String msg = \"\\\"&#123;\\\"name\\\": \\\"张三\\\",\\\"password\\\": \\\"@123456\\\",\\\"age\\\": \\\"15\\\"&#125;\\\"\"; // 去除转义 String msg1 = msg.replaceAll(\"\\\\\\\\\", \"\"); System.out.println(\"原来字符串:\"+msg); System.out.println(\"去除转义:\"+msg1); // 去除首尾\"\" String msg2 = msg1.substring(1, msg1.length() - 1); System.out.println(\"去除首尾双引号:\"+msg2); // 转为json JSONObject json = JSONObject.parseObject(msg2); System.out.println(\"转为json\"+json); String name = json.getString(\"name\"); System.out.println(\"json中name的值:\" + name);&#125; 运行结果： 12345原来字符串:\"&#123;\"name\": \"张三\",\"password\": \"@123456\",\"age\": \"15\"&#125;\"去除转义:\"&#123;\"name\": \"张三\",\"password\": \"@123456\",\"age\": \"15\"&#125;\"去除首尾双引号:&#123;\"name\": \"张三\",\"password\": \"@123456\",\"age\": \"15\"&#125;转为json&#123;\"password\":\"@123456\",\"name\":\"张三\",\"age\":\"15\"&#125;json中name的值:张三 2.基于spring和redis的redisTemplate工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574package cn.atwangjian.util;import org.springframework.data.redis.core.RedisTemplate;import org.springframework.util.CollectionUtils;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;/** * 基于spring和redis的redisTemplate工具类 * 针对所有的hash 都是以h开头的方法 * 针对所有的Set 都是以s开头的方法 不含通用方法 * 针对所有的List 都是以l开头的方法 * * @author wangjian * @date 2020/5/24 12:05 */public class RedisUtil &#123; private RedisTemplate&lt;String, Object&gt; redisTemplate; public void setRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; //=============================common============================ /** * 指定缓存失效时间 * * @param key 键 * @param time 时间(秒) * @return */ public boolean expire(String key, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.expire(key, time, TimeUnit.SECONDS); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据key 获取过期时间 * * @param key 键 不能为null * @return 时间(秒) 返回0代表为永久有效 */ public long getExpire(String key) &#123; return redisTemplate.getExpire(key, TimeUnit.SECONDS); &#125; /** * 判断key是否存在 * * @param key 键 * @return true 存在 false不存在 */ public boolean hasKey(String key) &#123; try &#123; return redisTemplate.hasKey(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除缓存 * * @param key 可以传一个值 或多个 */ @SuppressWarnings(\"unchecked\") public void del(String... key) &#123; if (key != null &amp;&amp; key.length &gt; 0) &#123; if (key.length == 1) &#123; redisTemplate.delete(key[0]); &#125; else &#123; redisTemplate.delete(CollectionUtils.arrayToList(key)); &#125; &#125; &#125; //============================String============================= /** * 普通缓存获取 * * @param key 键 * @return 值 */ public Object get(String key) &#123; return key == null ? null : redisTemplate.opsForValue().get(key); &#125; /** * 普通缓存放入 * * @param key 键 * @param value 值 * @return true成功 false失败 */ public boolean set(String key, Object value) &#123; try &#123; redisTemplate.opsForValue().set(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 普通缓存放入并设置时间 * * @param key 键 * @param value 值 * @param time 时间(秒) time要大于0 如果time小于等于0 将设置无限期 * @return true成功 false 失败 */ public boolean set(String key, Object value, long time) &#123; try &#123; if (time &gt; 0) &#123; redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS); &#125; else &#123; set(key, value); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 递增 * * @param key 键 * @param by 要增加几(大于0) * @return */ public long incr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(\"递增因子必须大于0\"); &#125; return redisTemplate.opsForValue().increment(key, delta); &#125; /** * 递减 * * @param key 键 * @param by 要减少几(小于0) * @return */ public long decr(String key, long delta) &#123; if (delta &lt; 0) &#123; throw new RuntimeException(\"递减因子必须大于0\"); &#125; return redisTemplate.opsForValue().increment(key, -delta); &#125; //================================Map================================= /** * HashGet * * @param key 键 不能为null * @param item 项 不能为null * @return 值 */ public Object hget(String key, String item) &#123; return redisTemplate.opsForHash().get(key, item); &#125; /** * 获取hashKey对应的所有键值 * * @param key 键 * @return 对应的多个键值 */ public Map&lt;Object, Object&gt; hmget(String key) &#123; return redisTemplate.opsForHash().entries(key); &#125; /** * HashSet * * @param key 键 * @param map 对应多个键值 * @return true 成功 false 失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * HashSet 并设置时间 * * @param key 键 * @param map 对应多个键值 * @param time 时间(秒) * @return true成功 false失败 */ public boolean hmset(String key, Map&lt;String, Object&gt; map, long time) &#123; try &#123; redisTemplate.opsForHash().putAll(key, map); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 向一张hash表中放入数据,如果不存在将创建 * * @param key 键 * @param item 项 * @param value 值 * @param time 时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间 * @return true 成功 false失败 */ public boolean hset(String key, String item, Object value, long time) &#123; try &#123; redisTemplate.opsForHash().put(key, item, value); if (time &gt; 0) &#123; expire(key, time); &#125; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 删除hash表中的值 * * @param key 键 不能为null * @param item 项 可以使多个 不能为null */ public void hdel(String key, Object... item) &#123; redisTemplate.opsForHash().delete(key, item); &#125; /** * 判断hash表中是否有该项的值 * * @param key 键 不能为null * @param item 项 不能为null * @return true 存在 false不存在 */ public boolean hHasKey(String key, String item) &#123; return redisTemplate.opsForHash().hasKey(key, item); &#125; /** * hash递增 如果不存在,就会创建一个 并把新增后的值返回 * * @param key 键 * @param item 项 * @param by 要增加几(大于0) * @return */ public double hincr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, by); &#125; /** * hash递减 * * @param key 键 * @param item 项 * @param by 要减少记(小于0) * @return */ public double hdecr(String key, String item, double by) &#123; return redisTemplate.opsForHash().increment(key, item, -by); &#125; //============================set============================= /** * 根据key获取Set中的所有值 * * @param key 键 * @return */ public Set&lt;Object&gt; sGet(String key) &#123; try &#123; return redisTemplate.opsForSet().members(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 根据value从一个set中查询,是否存在 * * @param key 键 * @param value 值 * @return true 存在 false不存在 */ public boolean sHasKey(String key, Object value) &#123; try &#123; return redisTemplate.opsForSet().isMember(key, value); &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将数据放入set缓存 * * @param key 键 * @param values 值 可以是多个 * @return 成功个数 */ public long sSet(String key, Object... values) &#123; try &#123; return redisTemplate.opsForSet().add(key, values); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 将set数据放入缓存 * * @param key 键 * @param time 时间(秒) * @param values 值 可以是多个 * @return 成功个数 */ public long sSetAndTime(String key, long time, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().add(key, values); if (time &gt; 0) expire(key, time); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 获取set缓存的长度 * * @param key 键 * @return */ public long sGetSetSize(String key) &#123; try &#123; return redisTemplate.opsForSet().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 移除值为value的 * * @param key 键 * @param values 值 可以是多个 * @return 移除的个数 */ public long setRemove(String key, Object... values) &#123; try &#123; Long count = redisTemplate.opsForSet().remove(key, values); return count; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; //===============================list================================= /** * 获取list缓存的内容 * * @param key 键 * @param start 开始 * @param end 结束 0 到 -1代表所有值 * @return */ public List&lt;Object&gt; lGet(String key, long start, long end) &#123; try &#123; return redisTemplate.opsForList().range(key, start, end); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 获取list缓存的长度 * * @param key 键 * @return */ public long lGetListSize(String key) &#123; try &#123; return redisTemplate.opsForList().size(key); &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; /** * 通过索引 获取list中的值 * * @param key 键 * @param index 索引 index&gt;=0时， 0 表头，1 第二个元素，依次类推；index&lt;0时，-1，表尾，-2倒数第二个元素，依次类推 * @return */ public Object lGetIndex(String key, long index) &#123; try &#123; return redisTemplate.opsForList().index(key, index); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, Object value, long time) &#123; try &#123; redisTemplate.opsForList().rightPush(key, value); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 将list放入缓存 * * @param key 键 * @param value 值 * @param time 时间(秒) * @return */ public boolean lSet(String key, List&lt;Object&gt; value, long time) &#123; try &#123; redisTemplate.opsForList().rightPushAll(key, value); if (time &gt; 0) expire(key, time); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 根据索引修改list中的某条数据 * * @param key 键 * @param index 索引 * @param value 值 * @return */ public boolean lUpdateIndex(String key, long index, Object value) &#123; try &#123; redisTemplate.opsForList().set(key, index, value); return true; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; &#125; /** * 移除N个值为value * * @param key 键 * @param count 移除多少个 * @param value 值 * @return 移除的个数 */ public long lRemove(String key, long count, Object value) &#123; try &#123; Long remove = redisTemplate.opsForList().remove(key, count, value); return remove; &#125; catch (Exception e) &#123; e.printStackTrace(); return 0; &#125; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://atwangjian.cn/categories/Java/"}],"tags":[{"name":"工具类","slug":"工具类","permalink":"http://atwangjian.cn/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"}],"keywords":[{"name":"Java","slug":"Java","permalink":"http://atwangjian.cn/categories/Java/"}]},{"title":"留言板","slug":"liuyanban","date":"2020-02-02T14:22:22.000Z","updated":"2020-04-05T13:17:20.099Z","comments":true,"path":"liuyanban.html","link":"","permalink":"http://atwangjian.cn/liuyanban.html","excerpt":"","text":"欢迎留下你的足迹！点开留言板在评论区随便说点什么吧~","categories":[],"tags":[],"keywords":[]}]}